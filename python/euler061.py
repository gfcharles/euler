"""
Triangle, square, pentagonal, hexagonal, heptagonal, and octagonal numbers are all figurate (polygonal) numbers
and are generated by the following formulas:

Triangle 	  	P_(3,n)=n(n+1)/2 	  	1, 3, 6, 10, 15, ...
Square 	  	    P_(4,n)=n^(2) 	  	    1, 4, 9, 16, 25, ...
Pentagonal 	  	P_(5,n)=n(3n-1)/2 	  	1, 5, 12, 22, 35, ...
Hexagonal 	  	P_(6,n)=n(2n-1) 	  	1, 6, 15, 28, 45, ...
Heptagonal 	  	P_(7,n)=n(5n-3)/2 	  	1, 7, 18, 34, 55, ...
Octagonal 	  	P_(8,n)=n(3n-2) 	  	1, 8, 21, 40, 65, ...

The ordered set of three 4-digit numbers: 8128, 2882, 8281, has three interesting properties.

   1. The set is cyclic, in that the last two digits of each number is the first two digits of the next number
        (including the last number with the first).

   2. Each polygonal type: triangle (P_(3,127)=8128), square (P_(4,91)=8281), and pentagonal (P_(5,44)=2882),
      is represented by a different number in the set.

   3. This is the only set of 4-digit numbers with this property.

Find the sum of the only ordered set of six cyclic 4-digit numbers for which each polygonal type:
triangle, square, pentagonal, hexagonal, heptagonal, and octagonal, is represented by a different number in the set.
"""
import logging
import typing
from functools import cache
from itertools import takewhile, dropwhile, count

from common import poly
from euler import euler_problem


# @euler_problem(timing=True, logging_level=logging.DEBUG)
@euler_problem()
def euler061(polygon_types: str) -> int:
    poly_fnc_list = fnc_list_for_types(polygon_types)

    # Sort by descending sides to reduce search paths.
    poly_fnc_list.sort(key=lambda fnc: -poly.sides_map[fnc])

    return find_sum_of_cycle(poly_fnc_list)


def fnc_list_for_types(polygon_types: str):
    return list(map(lambda pt: eval(f'poly.{pt.strip()}'), polygon_types.split(',')))


class PolygonValue:
    def __init__(self, value: int, polygon_fnc: typing.Callable):
        self.value: int = value
        self.type: typing.Callable = polygon_fnc

    def __repr__(self):
        return f'({self.type.__name__}, {self.value})'

    def __str__(self):
        return repr(self)


@cache
def values_in_range(fnc: typing.Callable[[int], int], lower: int, upper: int) -> list[int]:
    """
    Return list of values of the function that fall in the range lower (inclusive) to upper (exclusive)
    """
    return list(
        takewhile(lambda b: b < upper,
                  dropwhile(lambda a: a < lower,
                            (fnc(x) for x in count())
                            )
                  )
    )


def is_conflict(polygon_values: list[PolygonValue], fnc: typing.Callable[[int], int], value: int) -> bool:
    return any(pv.type == fnc or pv.value == value for pv in polygon_values)


def build_cycle(fnc_list: list[typing.Callable[[int], int]], target_length: int,
                polygon_list: list[PolygonValue]) -> bool:
    lower, upper = 1000, 10000
    if len(polygon_list) > 0:
        digits_to_match = polygon_list[-1].value % 100
        if digits_to_match < 10:
            return False
        lower, upper = digits_to_match * 100, digits_to_match * 100 + 100

    for fnc in fnc_list:
        # Warning here due to @cache decorator. There doesn't seem to be a fix for this.
        for value in values_in_range(fnc, lower, upper):
            if not is_conflict(polygon_list, fnc, value):
                polygon_list.append(PolygonValue(value, fnc))

                if (target_length == len(polygon_list)) and (polygon_list[0].value // 100) == (
                        polygon_list[-1].value % 100):
                    return True
                if len(polygon_list) < target_length and build_cycle(fnc_list, target_length, polygon_list):
                    return True

                polygon_list.pop()

    return False


def find_sum_of_cycle(fnc_list: list[typing.Callable[[int], int]]) -> int:
    polygon_list = list()
    if build_cycle(fnc_list, len(fnc_list), polygon_list):
        logging.debug(f'Cycle = {polygon_list}')
        return sum(p.value for p in polygon_list)

    raise Exception('Cycle not found')


if __name__ == '__main__':
    print(euler061('triangle, square, pentagonal'))
    print(euler061('triangle, square, pentagonal,hexagonal,heptagonal,octagonal'))
