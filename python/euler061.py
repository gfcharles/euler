'''
Triangle, square, pentagonal, hexagonal, heptagonal, and octagonal numbers are all figurate (polygonal) numbers
and are generated by the following formulas:

Triangle 	  	P_(3,n)=n(n+1)/2 	  	1, 3, 6, 10, 15, ...
Square 	  	    P_(4,n)=n^(2) 	  	    1, 4, 9, 16, 25, ...
Pentagonal 	  	P_(5,n)=n(3n-1)/2 	  	1, 5, 12, 22, 35, ...
Hexagonal 	  	P_(6,n)=n(2n-1) 	  	1, 6, 15, 28, 45, ...
Heptagonal 	  	P_(7,n)=n(5n-3)/2 	  	1, 7, 18, 34, 55, ...
Octagonal 	  	P_(8,n)=n(3n-2) 	  	1, 8, 21, 40, 65, ...

The ordered set of three 4-digit numbers: 8128, 2882, 8281, has three interesting properties.

   1. The set is cyclic, in that the last two digits of each number is the first two digits of the next number
        (including the last number with the first).

   2. Each polygonal type: triangle (P_(3,127)=8128), square (P_(4,91)=8281), and pentagonal (P_(5,44)=2882),
      is represented by a different number in the set.

   3. This is the only set of 4-digit numbers with this property.

Find the sum of the only ordered set of six cyclic 4-digit numbers for which each polygonal type:
triangle, square, pentagonal, hexagonal, heptagonal, and octagonal, is represented by a different number in the set.

Created on January 16, 2011
@author Greg Charles
'''
import poly


class Polygonal(object):

    def __init__(self, value,type):
        self.value = value
        self.type = type

    def __str__( self ):
        return 'P' + str(self.type) + ': ' + str(self.value)

    def conflictsWith(self,other):
        return self.value == other.value or self.type == other.type

    def conflictsWithSet(self, polySet):
        for poly in polySet:
            if self.conflictsWith(poly):
                return True
        return False

def createSequence(method, lower, upper):
    set, n = [], 0
    while True:
        nextValue = method(n)
        if nextValue >= upper:
            return set
        if nextValue >= lower:
            set.append(nextValue)
        n += 1

def createPolygonalSet(method, type):
    sequence = createSequence(method, 1000, 10000)
    return map(lambda value : Polygonal(value, type), filter(lambda n: n % 100 >= 10, sequence))


def createPolygonalMap(methods, types):
    pmap = [list() for x in range(0,100)]
    for i in range(len(methods)):
        set = createPolygonalSet(methods[i], types[i])
        for element in set:
            hash = element.value / 100
            pmap[hash].append(element)

    return pmap

def buildSet(set, map, max):
    hash = set[-1].value % 100
    possibles = map[hash]
    for possible in possibles:
        if not possible.conflictsWithSet(set):
            set.append(possible)

            if (len(set) == max) and ((set[0].value / 100) == (set[-1].value % 100)):
                return True
            if len(set) < max and buildSet(set, map, max):
                return True
            set.pop()

    return False


methods = [
    lambda n: poly.triangle(n),
    lambda n: poly.square(n),
    lambda n: poly.pentagonal(n),
    lambda n: poly.hexagonal(n),
    lambda n: poly.heptagonal(n),
    ]

types = [3,4,5,6,7]

pmap = createPolygonalMap(methods, types)
octagonals = createPolygonalSet(lambda n: poly.octagonal(n), 8)
for octagonal in octagonals:
    if octagonal.value != 1281:
        continue

    set = [octagonal]
    if buildSet(set, pmap, 6):
        print map(str, set)
        print sum(map(lambda x : x.value, set))
        break
