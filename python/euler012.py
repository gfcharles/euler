'''
The sequence of triangle numbers is generated by adding the natural numbers. 
So the 7^(th) triangle number would be 1 + 2 + 3 + 4 + 5 + 6 + 7 = 28. The first ten terms would be:

1, 3, 6, 10, 15, 21, 28, 36, 45, 55, ...

Let us list the factors of the first seven triangle numbers:

     1: 1
     3: 1,3
     6: 1,2,3,6
    10: 1,2,5,10
    15: 1,3,5,15
    21: 1,3,7,21
    28: 1,2,4,7,14,28

We can see that 28 is the first triangle number to have over five divisors.

What is the value of the first triangle number to have over five hundred divisors?

Created on Sep 14, 2010

@author: Greg Charles
'''
import math
import time

# Compute triangle number of value using injection to create a sum.
def triangle(value):
    return sum(range(1, value+1))

def CountTriangleFactors(n, countFactorsMethod):
    if (n % 2 == 0):
        return countFactorsMethod(n/2) * countFactorsMethod(n+1)
    else:
        return countFactorsMethod(n) * countFactorsMethod((n+1)/2)

# Straight up counting of factors
def countFactors(value):
    limit = int(math.floor(math.sqrt(value)))
    factors = 0
    for x in xrange(1,limit+1):
        if value % x == 0:
            factors += 2 
    
    # Make up for perfect squares
    if limit * limit == value:        
        factors -= 1
       
    return factors

# Count factors using some weird list methods.
def countFactors2(value): 
    limit = int(math.floor(math.sqrt(value)))
    factors = 2 * len(filter(lambda x: (value % x == 0), range(1,limit+1)))

    # Make up for perfect squares
    if limit * limit == value:        
        factors -= 1
       
    return factors


def runTrial(header, countFactorsMethod): 
    print header
  
    value = 0
    factors = 0

    start = time.clock()
    while factors <= 500:
        value +=1 
        factors = CountTriangleFactors(value, countFactorsMethod)

    print "Time elapsed ", (time.clock() - start), " seconds"
    print "Triangle number ", triangle(value), " has ", factors, " factors."


runTrial("Method 1", lambda x: countFactors(x))
runTrial("Method 2", lambda x: countFactors2(x))


'''
# Count factors weird Ruby way
def countFactors3(value)
  factors = 1
  value.prime_division.each {|factor, count| factors *= (count+1)}
  factors
end
'''
